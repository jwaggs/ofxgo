package ofxgo_test

/*
 * Do not edit this file by hand. It is auto-generated by calling `go generate`.
 * To make changes, edit generate_constants.py, re-run `go generate`, and check
 * in the result.
 */

import (
	"github.com/jwaggs/ofxgo"
	"github.com/aclindsa/xml"
	"strings"
	"testing"
)

func TestOfxVersion(t *testing.T) {
	e, err := ofxgo.NewOfxVersion("102")
	if err != nil {
		t.Fatalf("Unexpected error creating new OfxVersion from string \"102\"\n")
	}
	if !e.Valid() {
		t.Fatalf("OfxVersion unexpectedly invalid\n")
	}
	err = e.FromString("220")
	if err != nil {
		t.Fatalf("Unexpected error on OfxVersion.FromString(\"220\")\n")
	}
	if e.String() != "220" {
		t.Fatalf("OfxVersion.String() expected to be \"220\"\n")
	}

	marshalHelper(t, "220", &e)

	overwritten, err := ofxgo.NewOfxVersion("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new OfxVersion from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("OfxVersion created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("OfxVersion created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(OfxVersion): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "220", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestAcctType(t *testing.T) {
	e, err := ofxgo.NewAcctType("CHECKING")
	if err != nil {
		t.Fatalf("Unexpected error creating new AcctType from string \"CHECKING\"\n")
	}
	if !e.Valid() {
		t.Fatalf("AcctType unexpectedly invalid\n")
	}
	err = e.FromString("CD")
	if err != nil {
		t.Fatalf("Unexpected error on AcctType.FromString(\"CD\")\n")
	}
	if e.String() != "CD" {
		t.Fatalf("AcctType.String() expected to be \"CD\"\n")
	}

	marshalHelper(t, "CD", &e)

	overwritten, err := ofxgo.NewAcctType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new AcctType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("AcctType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("AcctType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(AcctType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "CD", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestTrnType(t *testing.T) {
	e, err := ofxgo.NewTrnType("CREDIT")
	if err != nil {
		t.Fatalf("Unexpected error creating new TrnType from string \"CREDIT\"\n")
	}
	if !e.Valid() {
		t.Fatalf("TrnType unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on TrnType.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("TrnType.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := ofxgo.NewTrnType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new TrnType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("TrnType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("TrnType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(TrnType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestImageType(t *testing.T) {
	e, err := ofxgo.NewImageType("STATEMENT")
	if err != nil {
		t.Fatalf("Unexpected error creating new ImageType from string \"STATEMENT\"\n")
	}
	if !e.Valid() {
		t.Fatalf("ImageType unexpectedly invalid\n")
	}
	err = e.FromString("TAX")
	if err != nil {
		t.Fatalf("Unexpected error on ImageType.FromString(\"TAX\")\n")
	}
	if e.String() != "TAX" {
		t.Fatalf("ImageType.String() expected to be \"TAX\"\n")
	}

	marshalHelper(t, "TAX", &e)

	overwritten, err := ofxgo.NewImageType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new ImageType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("ImageType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("ImageType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(ImageType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "TAX", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestImageRefType(t *testing.T) {
	e, err := ofxgo.NewImageRefType("OPAQUE")
	if err != nil {
		t.Fatalf("Unexpected error creating new ImageRefType from string \"OPAQUE\"\n")
	}
	if !e.Valid() {
		t.Fatalf("ImageRefType unexpectedly invalid\n")
	}
	err = e.FromString("FORMURL")
	if err != nil {
		t.Fatalf("Unexpected error on ImageRefType.FromString(\"FORMURL\")\n")
	}
	if e.String() != "FORMURL" {
		t.Fatalf("ImageRefType.String() expected to be \"FORMURL\"\n")
	}

	marshalHelper(t, "FORMURL", &e)

	overwritten, err := ofxgo.NewImageRefType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new ImageRefType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("ImageRefType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("ImageRefType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(ImageRefType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "FORMURL", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestCheckSup(t *testing.T) {
	e, err := ofxgo.NewCheckSup("FRONTONLY")
	if err != nil {
		t.Fatalf("Unexpected error creating new CheckSup from string \"FRONTONLY\"\n")
	}
	if !e.Valid() {
		t.Fatalf("CheckSup unexpectedly invalid\n")
	}
	err = e.FromString("FRONTANDBACK")
	if err != nil {
		t.Fatalf("Unexpected error on CheckSup.FromString(\"FRONTANDBACK\")\n")
	}
	if e.String() != "FRONTANDBACK" {
		t.Fatalf("CheckSup.String() expected to be \"FRONTANDBACK\"\n")
	}

	marshalHelper(t, "FRONTANDBACK", &e)

	overwritten, err := ofxgo.NewCheckSup("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new CheckSup from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("CheckSup created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("CheckSup created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(CheckSup): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "FRONTANDBACK", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestCorrectAction(t *testing.T) {
	e, err := ofxgo.NewCorrectAction("DELETE")
	if err != nil {
		t.Fatalf("Unexpected error creating new CorrectAction from string \"DELETE\"\n")
	}
	if !e.Valid() {
		t.Fatalf("CorrectAction unexpectedly invalid\n")
	}
	err = e.FromString("REPLACE")
	if err != nil {
		t.Fatalf("Unexpected error on CorrectAction.FromString(\"REPLACE\")\n")
	}
	if e.String() != "REPLACE" {
		t.Fatalf("CorrectAction.String() expected to be \"REPLACE\"\n")
	}

	marshalHelper(t, "REPLACE", &e)

	overwritten, err := ofxgo.NewCorrectAction("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new CorrectAction from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("CorrectAction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("CorrectAction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(CorrectAction): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "REPLACE", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestBalType(t *testing.T) {
	e, err := ofxgo.NewBalType("DOLLAR")
	if err != nil {
		t.Fatalf("Unexpected error creating new BalType from string \"DOLLAR\"\n")
	}
	if !e.Valid() {
		t.Fatalf("BalType unexpectedly invalid\n")
	}
	err = e.FromString("NUMBER")
	if err != nil {
		t.Fatalf("Unexpected error on BalType.FromString(\"NUMBER\")\n")
	}
	if e.String() != "NUMBER" {
		t.Fatalf("BalType.String() expected to be \"NUMBER\"\n")
	}

	marshalHelper(t, "NUMBER", &e)

	overwritten, err := ofxgo.NewBalType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new BalType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("BalType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("BalType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(BalType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "NUMBER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestInv401kSource(t *testing.T) {
	e, err := ofxgo.NewInv401kSource("PRETAX")
	if err != nil {
		t.Fatalf("Unexpected error creating new Inv401kSource from string \"PRETAX\"\n")
	}
	if !e.Valid() {
		t.Fatalf("Inv401kSource unexpectedly invalid\n")
	}
	err = e.FromString("OTHERNONVEST")
	if err != nil {
		t.Fatalf("Unexpected error on Inv401kSource.FromString(\"OTHERNONVEST\")\n")
	}
	if e.String() != "OTHERNONVEST" {
		t.Fatalf("Inv401kSource.String() expected to be \"OTHERNONVEST\"\n")
	}

	marshalHelper(t, "OTHERNONVEST", &e)

	overwritten, err := ofxgo.NewInv401kSource("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new Inv401kSource from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("Inv401kSource created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("Inv401kSource created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(Inv401kSource): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHERNONVEST", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestSubAcctType(t *testing.T) {
	e, err := ofxgo.NewSubAcctType("CASH")
	if err != nil {
		t.Fatalf("Unexpected error creating new SubAcctType from string \"CASH\"\n")
	}
	if !e.Valid() {
		t.Fatalf("SubAcctType unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on SubAcctType.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("SubAcctType.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := ofxgo.NewSubAcctType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new SubAcctType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("SubAcctType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("SubAcctType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(SubAcctType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestBuyType(t *testing.T) {
	e, err := ofxgo.NewBuyType("BUY")
	if err != nil {
		t.Fatalf("Unexpected error creating new BuyType from string \"BUY\"\n")
	}
	if !e.Valid() {
		t.Fatalf("BuyType unexpectedly invalid\n")
	}
	err = e.FromString("BUYTOCOVER")
	if err != nil {
		t.Fatalf("Unexpected error on BuyType.FromString(\"BUYTOCOVER\")\n")
	}
	if e.String() != "BUYTOCOVER" {
		t.Fatalf("BuyType.String() expected to be \"BUYTOCOVER\"\n")
	}

	marshalHelper(t, "BUYTOCOVER", &e)

	overwritten, err := ofxgo.NewBuyType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new BuyType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("BuyType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("BuyType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(BuyType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "BUYTOCOVER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestOptAction(t *testing.T) {
	e, err := ofxgo.NewOptAction("EXERCISE")
	if err != nil {
		t.Fatalf("Unexpected error creating new OptAction from string \"EXERCISE\"\n")
	}
	if !e.Valid() {
		t.Fatalf("OptAction unexpectedly invalid\n")
	}
	err = e.FromString("EXPIRE")
	if err != nil {
		t.Fatalf("Unexpected error on OptAction.FromString(\"EXPIRE\")\n")
	}
	if e.String() != "EXPIRE" {
		t.Fatalf("OptAction.String() expected to be \"EXPIRE\"\n")
	}

	marshalHelper(t, "EXPIRE", &e)

	overwritten, err := ofxgo.NewOptAction("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new OptAction from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("OptAction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("OptAction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(OptAction): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "EXPIRE", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestTferAction(t *testing.T) {
	e, err := ofxgo.NewTferAction("IN")
	if err != nil {
		t.Fatalf("Unexpected error creating new TferAction from string \"IN\"\n")
	}
	if !e.Valid() {
		t.Fatalf("TferAction unexpectedly invalid\n")
	}
	err = e.FromString("OUT")
	if err != nil {
		t.Fatalf("Unexpected error on TferAction.FromString(\"OUT\")\n")
	}
	if e.String() != "OUT" {
		t.Fatalf("TferAction.String() expected to be \"OUT\"\n")
	}

	marshalHelper(t, "OUT", &e)

	overwritten, err := ofxgo.NewTferAction("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new TferAction from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("TferAction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("TferAction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(TferAction): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OUT", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestPosType(t *testing.T) {
	e, err := ofxgo.NewPosType("LONG")
	if err != nil {
		t.Fatalf("Unexpected error creating new PosType from string \"LONG\"\n")
	}
	if !e.Valid() {
		t.Fatalf("PosType unexpectedly invalid\n")
	}
	err = e.FromString("SHORT")
	if err != nil {
		t.Fatalf("Unexpected error on PosType.FromString(\"SHORT\")\n")
	}
	if e.String() != "SHORT" {
		t.Fatalf("PosType.String() expected to be \"SHORT\"\n")
	}

	marshalHelper(t, "SHORT", &e)

	overwritten, err := ofxgo.NewPosType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new PosType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("PosType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("PosType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(PosType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "SHORT", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestSecured(t *testing.T) {
	e, err := ofxgo.NewSecured("NAKED")
	if err != nil {
		t.Fatalf("Unexpected error creating new Secured from string \"NAKED\"\n")
	}
	if !e.Valid() {
		t.Fatalf("Secured unexpectedly invalid\n")
	}
	err = e.FromString("COVERED")
	if err != nil {
		t.Fatalf("Unexpected error on Secured.FromString(\"COVERED\")\n")
	}
	if e.String() != "COVERED" {
		t.Fatalf("Secured.String() expected to be \"COVERED\"\n")
	}

	marshalHelper(t, "COVERED", &e)

	overwritten, err := ofxgo.NewSecured("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new Secured from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("Secured created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("Secured created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(Secured): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "COVERED", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestDuration(t *testing.T) {
	e, err := ofxgo.NewDuration("DAY")
	if err != nil {
		t.Fatalf("Unexpected error creating new Duration from string \"DAY\"\n")
	}
	if !e.Valid() {
		t.Fatalf("Duration unexpectedly invalid\n")
	}
	err = e.FromString("IMMEDIATE")
	if err != nil {
		t.Fatalf("Unexpected error on Duration.FromString(\"IMMEDIATE\")\n")
	}
	if e.String() != "IMMEDIATE" {
		t.Fatalf("Duration.String() expected to be \"IMMEDIATE\"\n")
	}

	marshalHelper(t, "IMMEDIATE", &e)

	overwritten, err := ofxgo.NewDuration("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new Duration from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("Duration created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("Duration created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(Duration): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "IMMEDIATE", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestRestriction(t *testing.T) {
	e, err := ofxgo.NewRestriction("ALLORNONE")
	if err != nil {
		t.Fatalf("Unexpected error creating new Restriction from string \"ALLORNONE\"\n")
	}
	if !e.Valid() {
		t.Fatalf("Restriction unexpectedly invalid\n")
	}
	err = e.FromString("NONE")
	if err != nil {
		t.Fatalf("Unexpected error on Restriction.FromString(\"NONE\")\n")
	}
	if e.String() != "NONE" {
		t.Fatalf("Restriction.String() expected to be \"NONE\"\n")
	}

	marshalHelper(t, "NONE", &e)

	overwritten, err := ofxgo.NewRestriction("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new Restriction from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("Restriction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("Restriction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(Restriction): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "NONE", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestUnitType(t *testing.T) {
	e, err := ofxgo.NewUnitType("SHARES")
	if err != nil {
		t.Fatalf("Unexpected error creating new UnitType from string \"SHARES\"\n")
	}
	if !e.Valid() {
		t.Fatalf("UnitType unexpectedly invalid\n")
	}
	err = e.FromString("CURRENCY")
	if err != nil {
		t.Fatalf("Unexpected error on UnitType.FromString(\"CURRENCY\")\n")
	}
	if e.String() != "CURRENCY" {
		t.Fatalf("UnitType.String() expected to be \"CURRENCY\"\n")
	}

	marshalHelper(t, "CURRENCY", &e)

	overwritten, err := ofxgo.NewUnitType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new UnitType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("UnitType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("UnitType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(UnitType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "CURRENCY", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestOptBuyType(t *testing.T) {
	e, err := ofxgo.NewOptBuyType("BUYTOOPEN")
	if err != nil {
		t.Fatalf("Unexpected error creating new OptBuyType from string \"BUYTOOPEN\"\n")
	}
	if !e.Valid() {
		t.Fatalf("OptBuyType unexpectedly invalid\n")
	}
	err = e.FromString("BUYTOCLOSE")
	if err != nil {
		t.Fatalf("Unexpected error on OptBuyType.FromString(\"BUYTOCLOSE\")\n")
	}
	if e.String() != "BUYTOCLOSE" {
		t.Fatalf("OptBuyType.String() expected to be \"BUYTOCLOSE\"\n")
	}

	marshalHelper(t, "BUYTOCLOSE", &e)

	overwritten, err := ofxgo.NewOptBuyType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new OptBuyType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("OptBuyType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("OptBuyType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(OptBuyType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "BUYTOCLOSE", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestSellType(t *testing.T) {
	e, err := ofxgo.NewSellType("SELL")
	if err != nil {
		t.Fatalf("Unexpected error creating new SellType from string \"SELL\"\n")
	}
	if !e.Valid() {
		t.Fatalf("SellType unexpectedly invalid\n")
	}
	err = e.FromString("SELLSHORT")
	if err != nil {
		t.Fatalf("Unexpected error on SellType.FromString(\"SELLSHORT\")\n")
	}
	if e.String() != "SELLSHORT" {
		t.Fatalf("SellType.String() expected to be \"SELLSHORT\"\n")
	}

	marshalHelper(t, "SELLSHORT", &e)

	overwritten, err := ofxgo.NewSellType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new SellType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("SellType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("SellType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(SellType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "SELLSHORT", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestLoanPmtFreq(t *testing.T) {
	e, err := ofxgo.NewLoanPmtFreq("WEEKLY")
	if err != nil {
		t.Fatalf("Unexpected error creating new LoanPmtFreq from string \"WEEKLY\"\n")
	}
	if !e.Valid() {
		t.Fatalf("LoanPmtFreq unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on LoanPmtFreq.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("LoanPmtFreq.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := ofxgo.NewLoanPmtFreq("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new LoanPmtFreq from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("LoanPmtFreq created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("LoanPmtFreq created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(LoanPmtFreq): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestIncomeType(t *testing.T) {
	e, err := ofxgo.NewIncomeType("CGLONG")
	if err != nil {
		t.Fatalf("Unexpected error creating new IncomeType from string \"CGLONG\"\n")
	}
	if !e.Valid() {
		t.Fatalf("IncomeType unexpectedly invalid\n")
	}
	err = e.FromString("MISC")
	if err != nil {
		t.Fatalf("Unexpected error on IncomeType.FromString(\"MISC\")\n")
	}
	if e.String() != "MISC" {
		t.Fatalf("IncomeType.String() expected to be \"MISC\"\n")
	}

	marshalHelper(t, "MISC", &e)

	overwritten, err := ofxgo.NewIncomeType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new IncomeType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("IncomeType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("IncomeType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(IncomeType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "MISC", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestSellReason(t *testing.T) {
	e, err := ofxgo.NewSellReason("CALL")
	if err != nil {
		t.Fatalf("Unexpected error creating new SellReason from string \"CALL\"\n")
	}
	if !e.Valid() {
		t.Fatalf("SellReason unexpectedly invalid\n")
	}
	err = e.FromString("MATURITY")
	if err != nil {
		t.Fatalf("Unexpected error on SellReason.FromString(\"MATURITY\")\n")
	}
	if e.String() != "MATURITY" {
		t.Fatalf("SellReason.String() expected to be \"MATURITY\"\n")
	}

	marshalHelper(t, "MATURITY", &e)

	overwritten, err := ofxgo.NewSellReason("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new SellReason from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("SellReason created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("SellReason created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(SellReason): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "MATURITY", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestOptSellType(t *testing.T) {
	e, err := ofxgo.NewOptSellType("SELLTOCLOSE")
	if err != nil {
		t.Fatalf("Unexpected error creating new OptSellType from string \"SELLTOCLOSE\"\n")
	}
	if !e.Valid() {
		t.Fatalf("OptSellType unexpectedly invalid\n")
	}
	err = e.FromString("SELLTOOPEN")
	if err != nil {
		t.Fatalf("Unexpected error on OptSellType.FromString(\"SELLTOOPEN\")\n")
	}
	if e.String() != "SELLTOOPEN" {
		t.Fatalf("OptSellType.String() expected to be \"SELLTOOPEN\"\n")
	}

	marshalHelper(t, "SELLTOOPEN", &e)

	overwritten, err := ofxgo.NewOptSellType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new OptSellType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("OptSellType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("OptSellType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(OptSellType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "SELLTOOPEN", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestRelType(t *testing.T) {
	e, err := ofxgo.NewRelType("SPREAD")
	if err != nil {
		t.Fatalf("Unexpected error creating new RelType from string \"SPREAD\"\n")
	}
	if !e.Valid() {
		t.Fatalf("RelType unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on RelType.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("RelType.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := ofxgo.NewRelType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new RelType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("RelType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("RelType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(RelType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestCharType(t *testing.T) {
	e, err := ofxgo.NewCharType("ALPHAONLY")
	if err != nil {
		t.Fatalf("Unexpected error creating new CharType from string \"ALPHAONLY\"\n")
	}
	if !e.Valid() {
		t.Fatalf("CharType unexpectedly invalid\n")
	}
	err = e.FromString("ALPHAANDNUMERIC")
	if err != nil {
		t.Fatalf("Unexpected error on CharType.FromString(\"ALPHAANDNUMERIC\")\n")
	}
	if e.String() != "ALPHAANDNUMERIC" {
		t.Fatalf("CharType.String() expected to be \"ALPHAANDNUMERIC\"\n")
	}

	marshalHelper(t, "ALPHAANDNUMERIC", &e)

	overwritten, err := ofxgo.NewCharType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new CharType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("CharType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("CharType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(CharType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "ALPHAANDNUMERIC", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestSyncMode(t *testing.T) {
	e, err := ofxgo.NewSyncMode("FULL")
	if err != nil {
		t.Fatalf("Unexpected error creating new SyncMode from string \"FULL\"\n")
	}
	if !e.Valid() {
		t.Fatalf("SyncMode unexpectedly invalid\n")
	}
	err = e.FromString("LITE")
	if err != nil {
		t.Fatalf("Unexpected error on SyncMode.FromString(\"LITE\")\n")
	}
	if e.String() != "LITE" {
		t.Fatalf("SyncMode.String() expected to be \"LITE\"\n")
	}

	marshalHelper(t, "LITE", &e)

	overwritten, err := ofxgo.NewSyncMode("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new SyncMode from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("SyncMode created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("SyncMode created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(SyncMode): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "LITE", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestOfxSec(t *testing.T) {
	e, err := ofxgo.NewOfxSec("NONE")
	if err != nil {
		t.Fatalf("Unexpected error creating new OfxSec from string \"NONE\"\n")
	}
	if !e.Valid() {
		t.Fatalf("OfxSec unexpectedly invalid\n")
	}
	err = e.FromString("TYPE 1")
	if err != nil {
		t.Fatalf("Unexpected error on OfxSec.FromString(\"TYPE 1\")\n")
	}
	if e.String() != "TYPE 1" {
		t.Fatalf("OfxSec.String() expected to be \"TYPE 1\"\n")
	}

	marshalHelper(t, "TYPE 1", &e)

	overwritten, err := ofxgo.NewOfxSec("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new OfxSec from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("OfxSec created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("OfxSec created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(OfxSec): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "TYPE 1", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestDebtType(t *testing.T) {
	e, err := ofxgo.NewDebtType("COUPON")
	if err != nil {
		t.Fatalf("Unexpected error creating new DebtType from string \"COUPON\"\n")
	}
	if !e.Valid() {
		t.Fatalf("DebtType unexpectedly invalid\n")
	}
	err = e.FromString("ZERO")
	if err != nil {
		t.Fatalf("Unexpected error on DebtType.FromString(\"ZERO\")\n")
	}
	if e.String() != "ZERO" {
		t.Fatalf("DebtType.String() expected to be \"ZERO\"\n")
	}

	marshalHelper(t, "ZERO", &e)

	overwritten, err := ofxgo.NewDebtType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new DebtType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("DebtType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("DebtType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(DebtType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "ZERO", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestDebtClass(t *testing.T) {
	e, err := ofxgo.NewDebtClass("TREASURY")
	if err != nil {
		t.Fatalf("Unexpected error creating new DebtClass from string \"TREASURY\"\n")
	}
	if !e.Valid() {
		t.Fatalf("DebtClass unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on DebtClass.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("DebtClass.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := ofxgo.NewDebtClass("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new DebtClass from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("DebtClass created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("DebtClass created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(DebtClass): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestCouponFreq(t *testing.T) {
	e, err := ofxgo.NewCouponFreq("MONTHLY")
	if err != nil {
		t.Fatalf("Unexpected error creating new CouponFreq from string \"MONTHLY\"\n")
	}
	if !e.Valid() {
		t.Fatalf("CouponFreq unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on CouponFreq.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("CouponFreq.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := ofxgo.NewCouponFreq("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new CouponFreq from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("CouponFreq created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("CouponFreq created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(CouponFreq): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestCallType(t *testing.T) {
	e, err := ofxgo.NewCallType("CALL")
	if err != nil {
		t.Fatalf("Unexpected error creating new CallType from string \"CALL\"\n")
	}
	if !e.Valid() {
		t.Fatalf("CallType unexpectedly invalid\n")
	}
	err = e.FromString("MATURITY")
	if err != nil {
		t.Fatalf("Unexpected error on CallType.FromString(\"MATURITY\")\n")
	}
	if e.String() != "MATURITY" {
		t.Fatalf("CallType.String() expected to be \"MATURITY\"\n")
	}

	marshalHelper(t, "MATURITY", &e)

	overwritten, err := ofxgo.NewCallType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new CallType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("CallType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("CallType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(CallType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "MATURITY", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestAssetClass(t *testing.T) {
	e, err := ofxgo.NewAssetClass("DOMESTICBOND")
	if err != nil {
		t.Fatalf("Unexpected error creating new AssetClass from string \"DOMESTICBOND\"\n")
	}
	if !e.Valid() {
		t.Fatalf("AssetClass unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on AssetClass.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("AssetClass.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := ofxgo.NewAssetClass("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new AssetClass from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("AssetClass created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("AssetClass created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(AssetClass): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestMfType(t *testing.T) {
	e, err := ofxgo.NewMfType("OPENEND")
	if err != nil {
		t.Fatalf("Unexpected error creating new MfType from string \"OPENEND\"\n")
	}
	if !e.Valid() {
		t.Fatalf("MfType unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on MfType.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("MfType.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := ofxgo.NewMfType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new MfType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("MfType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("MfType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(MfType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestOptType(t *testing.T) {
	e, err := ofxgo.NewOptType("PUT")
	if err != nil {
		t.Fatalf("Unexpected error creating new OptType from string \"PUT\"\n")
	}
	if !e.Valid() {
		t.Fatalf("OptType unexpectedly invalid\n")
	}
	err = e.FromString("CALL")
	if err != nil {
		t.Fatalf("Unexpected error on OptType.FromString(\"CALL\")\n")
	}
	if e.String() != "CALL" {
		t.Fatalf("OptType.String() expected to be \"CALL\"\n")
	}

	marshalHelper(t, "CALL", &e)

	overwritten, err := ofxgo.NewOptType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new OptType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("OptType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("OptType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(OptType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "CALL", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestStockType(t *testing.T) {
	e, err := ofxgo.NewStockType("COMMON")
	if err != nil {
		t.Fatalf("Unexpected error creating new StockType from string \"COMMON\"\n")
	}
	if !e.Valid() {
		t.Fatalf("StockType unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on StockType.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("StockType.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := ofxgo.NewStockType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new StockType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("StockType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("StockType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(StockType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestHolderType(t *testing.T) {
	e, err := ofxgo.NewHolderType("INDIVIDUAL")
	if err != nil {
		t.Fatalf("Unexpected error creating new HolderType from string \"INDIVIDUAL\"\n")
	}
	if !e.Valid() {
		t.Fatalf("HolderType unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on HolderType.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("HolderType.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := ofxgo.NewHolderType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new HolderType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("HolderType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("HolderType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(HolderType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestAcctClassification(t *testing.T) {
	e, err := ofxgo.NewAcctClassification("PERSONAL")
	if err != nil {
		t.Fatalf("Unexpected error creating new AcctClassification from string \"PERSONAL\"\n")
	}
	if !e.Valid() {
		t.Fatalf("AcctClassification unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on AcctClassification.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("AcctClassification.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := ofxgo.NewAcctClassification("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new AcctClassification from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("AcctClassification created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("AcctClassification created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(AcctClassification): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestSvcStatus(t *testing.T) {
	e, err := ofxgo.NewSvcStatus("AVAIL")
	if err != nil {
		t.Fatalf("Unexpected error creating new SvcStatus from string \"AVAIL\"\n")
	}
	if !e.Valid() {
		t.Fatalf("SvcStatus unexpectedly invalid\n")
	}
	err = e.FromString("ACTIVE")
	if err != nil {
		t.Fatalf("Unexpected error on SvcStatus.FromString(\"ACTIVE\")\n")
	}
	if e.String() != "ACTIVE" {
		t.Fatalf("SvcStatus.String() expected to be \"ACTIVE\"\n")
	}

	marshalHelper(t, "ACTIVE", &e)

	overwritten, err := ofxgo.NewSvcStatus("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new SvcStatus from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("SvcStatus created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("SvcStatus created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(SvcStatus): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "ACTIVE", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}

func TestUsProductType(t *testing.T) {
	e, err := ofxgo.NewUsProductType("401K")
	if err != nil {
		t.Fatalf("Unexpected error creating new UsProductType from string \"401K\"\n")
	}
	if !e.Valid() {
		t.Fatalf("UsProductType unexpectedly invalid\n")
	}
	err = e.FromString("UGMA")
	if err != nil {
		t.Fatalf("Unexpected error on UsProductType.FromString(\"UGMA\")\n")
	}
	if e.String() != "UGMA" {
		t.Fatalf("UsProductType.String() expected to be \"UGMA\"\n")
	}

	marshalHelper(t, "UGMA", &e)

	overwritten, err := ofxgo.NewUsProductType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new UsProductType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("UsProductType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("UsProductType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(UsProductType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "UGMA", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}
}
